<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Maestro</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
    <meta http-equiv="Pragma" content="no-cache"/>
    <meta http-equiv="Expires" content="0"/>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
            background-color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        th, td {
            border: 1px solid #eee;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
        tr:hover {
            background-color: #f8f9fa;
        }
        .status-succeeded {
            color: #2e7d32;
            font-weight: 500;
        }
        .status-created {
            color: #1976d2;
            font-weight: 500;
        }
        .status-failed {
            color: #d32f2f;
            font-weight: 500;
        }
        .status-in_progress {
            color: #ff9800;
            font-weight: 500;
        }
        .status-stopped {
            color: #9e9e9e;
            font-weight: 500;
        }
        .status-timed_out {
            color: #ff5722;
            font-weight: 500;
        }
        button {
            padding: 12px 24px;
            margin: 10px 0;
            cursor: pointer;
            background-color: #1976d2;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #1565c0;
        }
        .errors-container {
            margin-bottom: 20px;
        }
        .error-message {
            background-color: #ffebee;
            color: #c62828;
            padding: 12px;
            margin: 8px 0;
            border: 1px solid #ef9a9a;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .error-dismiss {
            background: none;
            border: none;
            color: #c62828;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 18px;
            margin: 0;
        }
        .error-dismiss:hover {
            background-color: rgba(198, 40, 40, 0.1);
            border-radius: 4px;
        }
        .instance-row {
            cursor: pointer;
        }
        .instance-details {
            display: none;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 4px;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .run-selector {
            margin-bottom: 15px;
        }
        .dag-container {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            margin-top: 15px;
            position: relative;
            overflow: auto;
        }
        .step-node {
            position: absolute;
            width: 150px;
            padding: 10px;
            border-radius: 4px;
            background-color: #e3f2fd;
            border: 1px solid #bbdefb;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            text-align: center;
            cursor: pointer;
            z-index: 1;
        }
        .step-node.selected {
            border: 2px solid #1976d2;
        }
        .step-node.status-succeeded {
            background-color: #e8f5e9;
            border-color: #c8e6c9;
        }
        .step-node.status-failed {
            background-color: #ffebee;
            border-color: #ffcdd2;
        }
        .step-node.status-in_progress {
            background-color: #fff8e1;
            border-color: #ffecb3;
        }
        .step-node.status-created, .step-node.status-initialized {
            background-color: #e3f2fd;
            border-color: #bbdefb;
        }
        .step-node.status-stopped {
            background-color: #f5f5f5;
            border-color: #e0e0e0;
        }
        .step-node.status-timed_out {
            background-color: #fbe9e7;
            border-color: #ffccbc;
        }
        .step-edge {
            position: absolute;
            height: 2px;
            background-color: #90caf9;
            z-index: 0;
            transform-origin: 0 0;
        }
        .step-details {
            margin-top: 15px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
        }
        .attempt-selector {
            margin-bottom: 10px;
        }
        .step-info {
            margin-top: 10px;
        }
        .step-info-item {
            margin-bottom: 5px;
        }
        .step-info-label {
            font-weight: bold;
        }
        .dropdown {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            background-color: white;
            font-size: 14px;
        }
        .clickable {
            cursor: pointer;
        }
    </style>
</head>
<body>
<div class="container">
    <h1 id="pageTitle">Workflow Instances</h1>
    <div id="errorsContainer" class="errors-container"></div>
    <button id="startButton" onclick="start()">Start New Instance</button>
    <table id="workflowTable">
        <thead>
            <tr>
                <th>Instance ID</th>
                <th>Status</th>
                <th>Create Time</th>
                <th>Start Time</th>
                <th>End Time</th>
                <th>UUID</th>
            </tr>
        </thead>
        <tbody id="result"></tbody>
    </table>

    <!-- Instance details container (hidden by default) -->
    <div id="instanceDetailsContainer" class="instance-details">
        <h2>Workflow Instance: <span id="instanceIdDisplay"></span></h2>

        <!-- Run selector -->
        <div class="run-selector">
            <label for="runSelector">Select Run: </label>
            <select id="runSelector" class="dropdown"></select>
        </div>

        <!-- DAG visualization -->
        <h3>Workflow Steps</h3>
        <div id="dagContainer" class="dag-container"></div>

        <!-- Step details -->
        <div id="stepDetailsContainer" class="step-details" style="display: none;">
            <h3>Step Details: <span id="stepIdDisplay"></span></h3>

            <!-- Attempt selector -->
            <div class="attempt-selector">
                <label for="attemptSelector">Select Attempt: </label>
                <select id="attemptSelector" class="dropdown"></select>
            </div>

            <!-- Step information -->
            <div id="stepInfo" class="step-info"></div>
        </div>
    </div>
</div>

<script>
    // Check if we're at the root path and redirect to /#/workflows/{workflowId}/instances if needed
    if (!window.location.hash) {
        // We're at the root path, redirect to /#/workflows/sample-python-client-workflow/instances
        window.location.href = '/#/workflows/sample-dag-test-1/instances';
    }

    // Get workflowId from URL hash: /#/workflows/{workflowId}/instances
    const hashParts = window.location.hash.substring(1).split('/').filter(part => part.length > 0);

    // Check if the URL has the correct format but workflowId is blank
    const hasWorkflowsPath = hashParts.length >= 1 && hashParts[0] === 'workflows';
    const isWorkflowIdBlank = hasWorkflowsPath && (hashParts.length === 1 || hashParts[1] === '');

    // Set workflowId based on URL hash
    const workflowId = hashParts[1];

    // Update page title with workflow ID
    if (workflowId) {
        document.getElementById('pageTitle').textContent = workflowId;
    }

    const errors = new Set();

    function formatDate(epoch) {
        if (epoch === undefined) {
            return '-';
        }

        if (epoch.toString().length === 10) {
            epoch *= 1000;
        }

        const date = new Date(epoch);

        const pad = (n) => n.toString().padStart(2, '0');

        const year = date.getFullYear();
        const month = pad(date.getMonth() + 1);
        const day = pad(date.getDate());
        const hours = pad(date.getHours());
        const minutes = pad(date.getMinutes());
        const seconds = pad(date.getSeconds());

        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }

    function showError(message, errorId = Date.now()) {
        const errorsContainer = document.getElementById('errorsContainer');
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.id = `error-${errorId}`;

        const messageSpan = document.createElement('span');
        messageSpan.textContent = message;

        const dismissButton = document.createElement('button');
        dismissButton.className = 'error-dismiss';
        dismissButton.innerHTML = 'Ã—';
        dismissButton.onclick = () => {
            errorDiv.remove();
            errors.delete(errorId);
        };

        errorDiv.appendChild(messageSpan);
        errorDiv.appendChild(dismissButton);

        if (!errors.has(errorId)) {
            errors.add(errorId);
            errorsContainer.appendChild(errorDiv);
        }
    }

    function handleResponse(response) {
        if (!response.ok) {
            return response.text().then(text => {
                let error;
                try {
                    error = JSON.parse(text);
                } catch (e) {
                    error = undefined;
                }
                if (error) {
                    throw new Error(error.message || `${response.status}: ${text}`);
                } else {
                    throw new Error(`${response.status}: ${text}`);
                }
            });
        }
        return response.json();
    }

    function start() {
        fetch(`/api/v3/workflows/${workflowId}/versions/latest/actions/start`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'user': 'tester'
            },
            body: JSON.stringify({
                initiator: {
                    type: 'manual'
                }
            })
        })
        .then(handleResponse)
        .then(data => {
            fetchInstances();
        })
        .catch(error => {
            console.error('Error:', error);
            showError('Error starting workflow: ' + error.message);
        });
    }

    // Global variables to store current state
    let currentInstanceId = null;
    let currentRunId = null;
    let currentStepId = null;
    let currentAttemptId = null;
    let currentInstance = null;
    let currentRun = null;
    let currentSteps = {};
    let currentStepAttempts = {};

    function fetchInstances() {
        fetch(`/api/v3/workflows/${workflowId}/instances?first=100`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
        })
        .then(handleResponse)
        .then(data => {
            const tbody = document.getElementById('result');
            tbody.innerHTML = data.elements.map(instance => `
                <tr class="instance-row" data-instance-id="${instance.workflow_instance_id}">
                    <td>${instance.workflow_instance_id}</td>
                    <td class="status-${instance.status.toLowerCase()}">${instance.status}</td>
                    <td>${formatDate(instance.create_time)}</td>
                    <td>${formatDate(instance.start_time)}</td>
                    <td>${formatDate(instance.end_time)}</td>
                    <td>${instance.workflow_uuid}</td>
                </tr>
            `).join('');

            // Add click handlers to instance rows
            document.querySelectorAll('.instance-row').forEach(row => {
                row.addEventListener('click', function() {
                    const instanceId = this.getAttribute('data-instance-id');
                    showInstanceDetails(instanceId);
                });
            });

            // If we have a currently selected instance, keep it selected
            if (currentInstanceId) {
                const row = document.querySelector(`.instance-row[data-instance-id="${currentInstanceId}"]`);
                if (row) {
                    row.classList.add('selected');
                }
            }
        })
        .catch(error => {
            console.error('Error:', error);
            showError('Error fetching data: ' + error.message);
        });
    }

    function showInstanceDetails(instanceId) {
        currentInstanceId = instanceId;
        document.getElementById('instanceIdDisplay').textContent = instanceId;

        // Show the instance details container
        document.getElementById('instanceDetailsContainer').style.display = 'block';

        // Fetch the instance details
        fetchInstanceDetails(instanceId);
    }

    function fetchInstanceDetails(instanceId) {
        fetch(`/api/v3/workflows/${workflowId}/instances/${instanceId}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
        })
        .then(handleResponse)
        .then(instance => {
            currentInstance = instance;

            // Fetch the runs for this instance
            fetchInstanceRuns(instanceId);
        })
        .catch(error => {
            console.error('Error:', error);
            showError('Error fetching instance details: ' + error.message);
        });
    }

    function fetchInstanceRuns(instanceId) {
        const runSelector = document.getElementById('runSelector');
        runSelector.innerHTML = '';

        // Add the latest run
        const option = document.createElement('option');
        option.value = currentInstance.workflow_run_id;
        option.textContent = `Run ${currentInstance.workflow_run_id} (Latest)`;
        runSelector.appendChild(option);

        // Set the current run ID
        currentRunId = currentInstance.workflow_run_id;

        // Fetch the run details
        fetchRunDetails(instanceId, currentRunId);

        // Add event listener to run selector
        runSelector.addEventListener('change', function() {
            currentRunId = this.value;
            fetchRunDetails(instanceId, currentRunId);
        });
    }

    function fetchRunDetails(instanceId, runId) {
        fetch(`/api/v3/workflows/${workflowId}/instances/${instanceId}/runs/${runId}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
        })
        .then(handleResponse)
        .then(run => {
            currentRun = run;

            // Visualize the DAG
            visualizeDAG(run);
        })
        .catch(error => {
            console.error('Error:', error);
            showError('Error fetching run details: ' + error.message);
        });
    }

    async function visualizeDAG(run) {
        const dagContainer = document.getElementById('dagContainer');
        dagContainer.innerHTML = '';

        // Hide step details
        document.getElementById('stepDetailsContainer').style.display = 'none';

        // Reset current steps
        currentSteps = {};

        // Check if we have a runtime DAG
        if (!run.runtime_dag) {
            dagContainer.innerHTML = '<p>No DAG information available for this run.</p>';
            return;
        }

        // Get the steps from the runtime workflow
        const steps = run.runtime_workflow.steps;
        if (!steps || steps.length === 0) {
            dagContainer.innerHTML = '<p>No steps available for this run.</p>';
            return;
        }

        // Create nodes for each step
        const nodes = {};
        const horizontalSpacing = 200;
        const verticalSpacing = 100;

        // First, create a map of step ID to step
        const stepsMap = {};
        steps.forEach(stepObj => {
            const step = stepObj.step;
            stepsMap[step.id] = step;
            currentSteps[step.id] = step;
        });

        // Create a map of step ID to level (depth in the DAG)
        const levels = {};
        const visited = new Set();

        // Find root nodes (steps with no predecessors)
        const rootNodes = [];
        for (const stepId in run.runtime_dag) {
            const transition = run.runtime_dag[stepId];
            if (!transition.predecessors || transition.predecessors.length === 0) {
                rootNodes.push(stepId);
            }
        }

        // Assign levels to nodes using BFS
        const queue = rootNodes.map(id => ({ id, level: 0 }));
        while (queue.length > 0) {
            const { id, level } = queue.shift();
            if (visited.has(id)) continue;

            visited.add(id);
            levels[id] = level;

            // Add successors to queue
            const transition = run.runtime_dag[id];
            if (transition && transition.successors) {
                for (const successorId in transition.successors) {
                    queue.push({ id: successorId, level: level + 1 });
                }
            }
        }

        // Count nodes at each level
        const nodesAtLevel = {};
        for (const id in levels) {
            const level = levels[id];
            nodesAtLevel[level] = (nodesAtLevel[level] || 0) + 1;
        }

        // Calculate positions for each node
        const positions = {};
        for (const id in levels) {
            const level = levels[id];
            const levelNodes = Object.entries(levels)
                .filter(([_, l]) => l === level)
                .map(([id]) => id);

            const index = levelNodes.indexOf(id);
            const x = level * horizontalSpacing + 50;
            const y = (index + 0.5) * verticalSpacing + 50;

            positions[id] = { x, y };
        }

        // Create nodes
        for (const stepId in stepsMap) {
            const step = stepsMap[stepId];
            const position = positions[stepId] || { x: 50, y: 50 };

            // Get step status from runtime overview
            const stepDetails = await fetchStepDetails(stepId);
            let status = stepDetails.runtime_state.status;

            // Create node element
            const node = document.createElement('div');
            node.className = `step-node status-${status.toLowerCase()}`;
            node.id = `step-${stepId}`;
            node.setAttribute('data-step-id', stepId);
            node.style.left = `${position.x}px`;
            node.style.top = `${position.y}px`;
            node.innerHTML = `
                <div>${step.id}</div>
                <div class="status-${status.toLowerCase()}">${status}</div>
            `;

            // Add click handler
            node.addEventListener('click', function() {
                // Deselect all nodes
                document.querySelectorAll('.step-node').forEach(n => n.classList.remove('selected'));

                // Select this node
                this.classList.add('selected');

                // Show step details
                showStepDetails(stepDetails);
            });

            dagContainer.appendChild(node);
            nodes[stepId] = node;
        }

        // Create edges
        for (const stepId in run.runtime_dag) {
            const transition = run.runtime_dag[stepId];
            if (transition && transition.successors) {
                for (const successorId in transition.successors) {
                    createEdge(stepId, successorId, nodes);
                }
            }
        }
    }

    function createEdge(fromId, toId, nodes) {
        const fromNode = nodes[fromId];
        const toNode = nodes[toId];

        if (!fromNode || !toNode) return;

        const fromRect = fromNode.getBoundingClientRect();
        const toRect = toNode.getBoundingClientRect();

        const dagContainer = document.getElementById('dagContainer');
        const containerRect = dagContainer.getBoundingClientRect();

        const fromX = parseInt(fromNode.style.left) + 150; // Right side of from node
        const fromY = parseInt(fromNode.style.top) + 30; // Middle of from node
        const toX = parseInt(toNode.style.left); // Left side of to node
        const toY = parseInt(toNode.style.top) + 30; // Middle of to node

        const length = Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
        const angle = Math.atan2(toY - fromY, toX - fromX);

        const edge = document.createElement('div');
        edge.className = 'step-edge';
        edge.style.width = `${length}px`;
        edge.style.left = `${fromX}px`;
        edge.style.top = `${fromY}px`;
        edge.style.transform = `rotate(${angle}rad)`;

        dagContainer.appendChild(edge);
    }

    function showStepDetails(step) {
        document.getElementById('stepIdDisplay').textContent = step.id;
        document.getElementById('stepDetailsContainer').style.display = 'block';
        populateAttemptSelector(step);
        displayStepInfo(step);
    }

    function fetchStepDetails(stepId) {
        return fetch(`/api/v3/workflows/${workflowId}/instances/${currentInstanceId}/steps/${stepId}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
        })
        .then(handleResponse)
        .then(step => {
            // Populate attempt selector
            populateAttemptSelector(step);

            // Display step info
            displayStepInfo(step);

            return step;
        })
        .catch(error => {
            console.error('Error:', error);
            showError('Error fetching step details: ' + error.message);
        });
    }

    function populateAttemptSelector(step) {
        const attemptSelector = document.getElementById('attemptSelector');
        attemptSelector.innerHTML = '';

        // Add the latest attempt
        const option = document.createElement('option');
        option.value = step.step_attempt_id;
        option.textContent = `Attempt ${step.step_attempt_id} (Latest)`;
        attemptSelector.appendChild(option);

        // Set the current attempt ID
        currentAttemptId = step.step_attempt_id;

        // Add event listener to attempt selector
        attemptSelector.addEventListener('change', function() {
            currentAttemptId = this.value;
            fetchStepAttempt(currentStepId, currentAttemptId);
        });
    }

    function fetchStepAttempt(stepId, attemptId) {
        fetch(`/api/v3/workflows/${workflowId}/instances/${currentInstanceId}/runs/${currentRunId}/steps/${stepId}/attempts/${attemptId}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
        })
        .then(handleResponse)
        .then(attempt => {
            // Display step attempt info
            displayStepInfo(attempt);
        })
        .catch(error => {
            console.error('Error:', error);
            showError('Error fetching step attempt: ' + error.message);
        });
    }

    function displayStepInfo(step) {
        const stepInfo = document.getElementById('stepInfo');
        stepInfo.innerHTML = '';

        // Display step properties
        console.log("step", step);
        const properties = [
            { label: 'ID', value: step.step_id },
            { label: 'Status', value: step.runtime_state ? step.runtime_state.status : 'N/A', class: step.runtime_state ? `status-${step.runtime_state.status.toLowerCase()}` : '' },
            { label: 'Type', value: step?.definition?.step?.type || 'N/A' },
            { label: 'Start Time', value: formatDate(step.runtime_state ? step.runtime_state.start_time : null) },
            { label: 'End Time', value: formatDate(step.runtime_state ? step.runtime_state.end_time : null) },
            { label: 'Duration', value: calculateDuration(step.runtime_state ? step.runtime_state.start_time : null, step.runtime_state ? step.runtime_state.end_time : null) }
        ];

        properties.forEach(prop => {
            const item = document.createElement('div');
            item.className = 'step-info-item';
            item.innerHTML = `
                <span class="step-info-label">${prop.label}:</span>
                <span ${prop.class ? `class="${prop.class}"` : ''}>${prop.value}</span>
            `;
            stepInfo.appendChild(item);
        });
    }

    function calculateDuration(startTime, endTime) {
        if (!startTime) return 'N/A';

        const start = new Date(startTime);
        const end = endTime ? new Date(endTime) : new Date();

        const durationMs = end - start;
        const seconds = Math.floor(durationMs / 1000);

        if (seconds < 60) {
            return `${seconds} seconds`;
        } else if (seconds < 3600) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes} minutes, ${remainingSeconds} seconds`;
        } else {
            const hours = Math.floor(seconds / 3600);
            const remainingMinutes = Math.floor((seconds % 3600) / 60);
            return `${hours} hours, ${remainingMinutes} minutes`;
        }
    }

    function checkWorkflowExists() {
        fetch(`/api/v3/workflows/${workflowId}/versions/latest`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(error => {
                    if (error.status === 'NOT_FOUND') {
                        // Workflow doesn't exist
                        showError(`Workflow [${workflowId}] has not been created yet or has been deleted.`);

                        // Hide the start button and table
                        document.getElementById('startButton').style.display = 'none';
                        document.getElementById('workflowTable').style.display = 'none';
                    } else {
                        throw new Error(error.message || `${response.status}: ${JSON.stringify(error)}`);
                    }
                });
            } else {
                // Workflow exists, fetch instances
                fetchInstances();

                // Refresh every X seconds
                setInterval(fetchInstances, 2000);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            showError('Error checking workflow: ' + error.message);
        });
    }

    // Wait for the DOM to be fully loaded before manipulating elements
    document.addEventListener('DOMContentLoaded', function() {
        // Check if workflowId is blank and show error if it is
        if (isWorkflowIdBlank) {
            // Show error message
            showError('Workflow ID is blank. Please provide a valid workflow ID in the URL.');

            // Disable the start button
            document.getElementById('startButton').disabled = true;
            document.getElementById('startButton').style.backgroundColor = '#cccccc';
            document.getElementById('startButton').style.cursor = 'not-allowed';
        } else {
            // Check if workflow exists before fetching instances
            checkWorkflowExists();
        }
    });
</script>
</body>
</html>
