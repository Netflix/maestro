/*
 * Copyright 2024 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package com.netflix.maestro.engine.steps;

import com.netflix.maestro.engine.concurrency.InstanceStepConcurrencyHandler;
import com.netflix.maestro.engine.dao.MaestroStepInstanceDao;
import com.netflix.maestro.engine.dao.MaestroWorkflowInstanceDao;
import com.netflix.maestro.engine.eval.ParamEvaluator;
import com.netflix.maestro.engine.execution.RunRequest;
import com.netflix.maestro.engine.execution.StepRuntimeSummary;
import com.netflix.maestro.engine.execution.WorkflowSummary;
import com.netflix.maestro.engine.handlers.WorkflowActionHandler;
import com.netflix.maestro.engine.utils.StepHelper;
import com.netflix.maestro.exceptions.MaestroBadRequestException;
import com.netflix.maestro.exceptions.MaestroInternalError;
import com.netflix.maestro.exceptions.MaestroRetryableError;
import com.netflix.maestro.models.Constants;
import com.netflix.maestro.models.artifact.Artifact;
import com.netflix.maestro.models.artifact.WhileArtifact;
import com.netflix.maestro.models.definition.Step;
import com.netflix.maestro.models.definition.Tag;
import com.netflix.maestro.models.definition.WhileStep;
import com.netflix.maestro.models.definition.Workflow;
import com.netflix.maestro.models.error.Details;
import com.netflix.maestro.models.instance.RestartConfig;
import com.netflix.maestro.models.instance.RunPolicy;
import com.netflix.maestro.models.instance.StepInstance;
import com.netflix.maestro.models.instance.WorkflowInstance;
import com.netflix.maestro.models.instance.WorkflowRollupOverview;
import com.netflix.maestro.models.instance.WorkflowRuntimeOverview;
import com.netflix.maestro.models.parameter.BooleanParameter;
import com.netflix.maestro.models.parameter.MapParameter;
import com.netflix.maestro.models.parameter.ParamDefinition;
import com.netflix.maestro.models.parameter.Parameter;
import com.netflix.maestro.models.timeline.TimelineDetailsEvent;
import com.netflix.maestro.models.timeline.TimelineEvent;
import com.netflix.maestro.models.timeline.TimelineLogEvent;
import com.netflix.maestro.queue.MaestroQueueSystem;
import com.netflix.maestro.queue.models.MessageDto;
import com.netflix.maestro.utils.Checks;
import com.netflix.maestro.utils.ObjectHelper;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * While step runtime. It supports empty loop as well. While step will manage the run strategy of
 * all workflow instances it generates by itself to reduce the load on run strategy manager.
 * Additionally, there is no run_properties for workflow instance generated by while step.
 *
 * <p>Note that while inline workflow cannot be restarted by users. But its run_id might not match
 * the upstream workflow with the corresponding while step if users restart the while step.
 *
 * <p>In while restart, cannot change the while condition parameter, so we ensure the iterations are
 * the same. Otherwise, users should start a new run.
 */
@Slf4j
@AllArgsConstructor
public class WhileStepRuntime implements StepRuntime {
  private static final String WHILE_TAG_NAME = Constants.WHILE_INLINE_WORKFLOW_PREFIX;
  private static final String CONDITION_PARAM_NAME = "condition";

  private final WorkflowActionHandler actionHandler;
  private final MaestroWorkflowInstanceDao instanceDao;
  private final MaestroStepInstanceDao stepInstanceDao;
  private final MaestroQueueSystem queueSystem;
  private final InstanceStepConcurrencyHandler instanceStepConcurrencyHandler;
  private final ParamEvaluator paramEvaluator;

  /** While step runtime start will initialize while artifact with info. */
  @Override
  public Result start(
      WorkflowSummary workflowSummary, Step step, StepRuntimeSummary runtimeSummary) {
    try {
      Artifact artifact = createArtifact(workflowSummary, runtimeSummary);
      return new Result(
          State.DONE,
          Collections.singletonMap(artifact.getType().key(), artifact),
          Collections.emptyList());
    } catch (MaestroRetryableError mre) {
      // retryable error, will retry by the parent logics
      throw mre;
    } catch (Exception e) {
      LOG.error(
          "Failed to start while step runtime for {}{}",
          workflowSummary.getIdentity(),
          runtimeSummary.getIdentity(),
          e);
      return new Result(
          State.FATAL_ERROR,
          Collections.emptyMap(),
          Collections.singletonList(
              TimelineDetailsEvent.from(
                  Details.create(e, false, "Failed to start while step runtime with an error"))));
    }
  }

  private WhileArtifact createArtifact(
      WorkflowSummary workflowSummary, StepRuntimeSummary runtimeSummary) {
    WhileArtifact artifact = new WhileArtifact();
    artifact.setLoopWorkflowId(
        StepHelper.generateInlineWorkflowId(workflowSummary, runtimeSummary));
    artifact.setLoopIdentity(workflowSummary.getIdentity() + runtimeSummary.getIdentity());
    artifact.setLoopRunId(1L);

    // inline run should match its upstream run.
    artifact.setRunId(workflowSummary.getWorkflowRunId());
    if (runtimeSummary.getRestartConfig() != null) {
      artifact.setRunPolicy(runtimeSummary.getRestartConfig().getRestartPolicy());
    } else {
      artifact.setRunPolicy(workflowSummary.getRunPolicy());
    }

    artifact.setFirstIteration(1);
    artifact.setLastIteration(0);
    artifact.setRollup(new WorkflowRollupOverview());
    artifact.setLoopParamValues(new LinkedHashMap<>());

    runtimeSummary
        .getParams()
        .get(Constants.LOOP_PARAMS_NAME)
        .asMap()
        .forEach(
            (key, value) ->
                artifact
                    .getLoopParamValues()
                    .computeIfAbsent(key, k -> new ArrayList<>())
                    .add(value));

    // restart from workflow or restart the step
    if (!workflowSummary.isFreshRun() || !runtimeSummary.getStepRetry().isRetryable()) {
      WhileArtifact prevArtifact =
          stepInstanceDao.getLatestWhileArtifact(
              workflowSummary.getWorkflowId(),
              workflowSummary.getWorkflowInstanceId(),
              runtimeSummary.getStepId());
      if (prevArtifact != null) {
        artifact.setLoopRunId(prevArtifact.getLoopRunId() + 1);

        long toRestart = 0;
        if (artifact.getRunPolicy() == RunPolicy.RESTART_FROM_SPECIFIC) {
          RestartConfig config =
              ObjectHelper.valueOrDefault(
                  runtimeSummary.getRestartConfig(), workflowSummary.getRestartConfig());
          toRestart = // this is the iteration id specified during restart from specific path
              RunRequest.getNextNode(config)
                  .filter(
                      node -> Objects.equals(node.getWorkflowId(), artifact.getLoopWorkflowId()))
                  .map(RestartConfig.RestartNode::getInstanceId)
                  .orElse(0L);
        } else if (artifact.getRunPolicy() == RunPolicy.RESTART_FROM_INCOMPLETE) {
          // continue the previous run
          toRestart = prevArtifact.getLastIteration();
        }

        if (toRestart > 0) {
          artifact.setFirstIteration(toRestart);
          artifact.setLastIteration(toRestart - 1);
          if (toRestart == prevArtifact.getLastIteration()) {
            artifact.setRollup(prevArtifact.getRollup());
          } else if (toRestart < prevArtifact.getLastIteration()) {
            // re-aggregate rollup
            artifact.setRollup(
                getAggregatedRollupFromIterations(prevArtifact.getLoopWorkflowId(), toRestart));
          } else {
            throw new MaestroBadRequestException(
                List.of(),
                "Invalid restart at %s%s as the iteration to restart [%s] is over the previous last iteration [%s]",
                workflowSummary.getIdentity(),
                runtimeSummary.getIdentity(),
                toRestart,
                prevArtifact.getLastIteration());
          }
          int end = (int) toRestart; // include the loop param values for the iteration to restart
          prevArtifact
              .getLoopParamValues()
              .forEach((k, v) -> artifact.getLoopParamValues().put(k, v.subList(0, end)));
        }
      }
    }

    return artifact;
  }

  /**
   * Get aggregated rollup before toRestart iteration in batches.
   *
   * @param whileLoopWorkflowId workflow id of the while loop inline workflow
   * @param toRestart the instance id to restart from, which is the max iteration id
   * @return aggregated rollups for the passed iteration ids
   */
  @SuppressWarnings("PMD.AvoidReassigningLoopVariables")
  private WorkflowRollupOverview getAggregatedRollupFromIterations(
      String whileLoopWorkflowId, long toRestart) {
    WorkflowRollupOverview aggregated = new WorkflowRollupOverview();
    for (int i = 1; i < toRestart; ) {
      int endId = (int) Math.min(i + Constants.BATCH_SIZE_ROLLUP_STEP_ARTIFACTS_QUERY, toRestart);
      List<WorkflowRollupOverview> rollups =
          instanceDao.getBatchWhileLatestRunRollupForIterations(whileLoopWorkflowId, i, endId);
      rollups.forEach(aggregated::aggregate);
      i = endId;
    }
    return aggregated;
  }

  /** while step runtime execute to launch and monitor while loop iterations. */
  @Override
  public Result execute(
      WorkflowSummary workflowSummary, Step step, StepRuntimeSummary runtimeSummary) {
    try {
      WhileArtifact artifact =
          runtimeSummary.getArtifacts().get(Artifact.Type.WHILE.key()).asWhile();

      // this check the current running while loop status
      Result result =
          trackWhileIteration(workflowSummary, runtimeSummary, (WhileStep) step, artifact);

      if (result == null) {
        return runWhileIteration(workflowSummary, (WhileStep) step, runtimeSummary, artifact);
      }
      return result;
    } catch (MaestroRetryableError mre) {
      LOG.info("Failed to execute while step runtime, will retry", mre);
      return new Result(
          State.CONTINUE,
          Collections.emptyMap(),
          Collections.singletonList(TimelineDetailsEvent.from(mre.getDetails())));
    } catch (Exception e) {
      LOG.error(
          "Failed to execute while step runtime {}{}",
          workflowSummary.getIdentity(),
          runtimeSummary.getIdentity(),
          e);
      return new Result(
          State.FATAL_ERROR,
          Collections.emptyMap(),
          Collections.singletonList(
              TimelineDetailsEvent.from(
                  Details.create(e, false, "Failed to execute while step runtime with an error"))));
    }
  }

  private Result trackWhileIteration(
      WorkflowSummary summary,
      StepRuntimeSummary runtimeSummary,
      WhileStep step,
      WhileArtifact artifact) {
    var status = refreshIterationOverview(artifact);
    if (status == null) {
      return new Result(
          State.CONTINUE,
          Collections.singletonMap(artifact.getType().key(), artifact),
          Collections.emptyList());
    }

    State state =
        switch (status) {
          case CREATED, IN_PROGRESS, PAUSED -> State.CONTINUE;
          case SUCCEEDED -> null; // indicate unknown
          case FAILED -> State.FATAL_ERROR; // no retry for while step
          case STOPPED -> State.STOPPED;
          case TIMED_OUT -> State.TIMED_OUT;
        };

    if (state != null) {
      TimelineEvent timelineEvent = null;
      if (status.isTerminal()) {
        timelineEvent =
            TimelineLogEvent.info(
                "While step is in [%s] status because its loop instance [%s][%s][%s] is in [%s] status",
                state,
                artifact.getLoopWorkflowId(),
                artifact.getLastIteration(),
                artifact.getLoopRunId(),
                status);
      }

      return new Result(
          state,
          Collections.singletonMap(artifact.getType().key(), artifact),
          timelineEvent == null
              ? Collections.emptyList()
              : Collections.singletonList(timelineEvent));
    } else {
      long curInstanceId = artifact.getLastIteration();
      if (curInstanceId >= artifact.getFirstIteration()) {
        updateWhileParams(artifact);
      }
      Parameter condition = evalCondition(summary, runtimeSummary, step, artifact);
      if (condition.asBoolean()) {
        return null;
      }
      return new Result(
          State.DONE,
          Collections.singletonMap(artifact.getType().key(), artifact),
          Collections.singletonList(
              TimelineLogEvent.info(
                  "while step is done at iteration [%s] because its next condition is false",
                  curInstanceId)));
    }
  }

  private Parameter evalCondition(
      WorkflowSummary summary,
      StepRuntimeSummary runtimeSummary,
      WhileStep step,
      WhileArtifact artifact) {
    // Directly update those loop params in step runtime summary, but they won't be persisted
    Map<String, Object> updatedLoopParamValues = new LinkedHashMap<>();
    artifact.getLoopParamValues().forEach((k, v) -> updatedLoopParamValues.put(k, v.getLast()));
    MapParameter loopParams =
        runtimeSummary.getParams().get(Constants.LOOP_PARAMS_NAME).asMapParam();
    loopParams.setEvaluatedResult(updatedLoopParamValues);
    // evaluate condition
    Map<String, Parameter> allStepParams = new LinkedHashMap<>(runtimeSummary.getParams());
    allStepParams.remove(Constants.LOOP_PARAMS_NAME);
    for (String name : loopParams.getParamNames()) {
      Parameter param = loopParams.getEvaluatedParam(name);
      allStepParams.put(name, param);
    }
    Parameter condition =
        BooleanParameter.builder()
            .name(CONDITION_PARAM_NAME)
            .expression(step.getCondition())
            .build();
    paramEvaluator.parseStepParameter(
        Collections.emptyMap(), summary.getParams(), allStepParams, condition, step.getId());
    return condition;
  }

  // re-eval loop params and conditions
  private void updateWhileParams(WhileArtifact artifact) {
    List<StepInstance> stepViews =
        stepInstanceDao.getStepInstanceViews(
            artifact.getLoopWorkflowId(), artifact.getLastIteration(), artifact.getLoopRunId());
    stepViews.sort(Comparator.comparingLong(StepInstance::getStepInstanceId));

    Map<String, Object> updatedLoopParamValues = new LinkedHashMap<>();
    artifact.getLoopParamValues().forEach((k, v) -> updatedLoopParamValues.put(k, v.getLast()));
    for (StepInstance stepView : stepViews) {
      stepView.getParams().entrySet().stream()
          .filter(entry -> updatedLoopParamValues.containsKey(entry.getKey()))
          .forEach(
              entry ->
                  updatedLoopParamValues.put(
                      entry.getKey(), entry.getValue().getEvaluatedResult()));
    }
    updatedLoopParamValues.forEach(
        (key, value) -> artifact.getLoopParamValues().get(key).add(value));
  }

  private Result runWhileIteration(
      WorkflowSummary workflowSummary,
      WhileStep step,
      StepRuntimeSummary runtimeSummary,
      WhileArtifact artifact) {
    long nextInstanceId = artifact.getLastIteration() + 1;
    Checks.checkTrue(
        nextInstanceId <= Constants.ITERATION_LIMIT,
        "While loop iteration count [%s] is over the loop size limit [%s] for step %s%s",
        nextInstanceId,
        Constants.ITERATION_LIMIT,
        workflowSummary.getIdentity(),
        runtimeSummary.getIdentity());

    Workflow inlineWorkflow =
        createInlineWorkflow(artifact.getLoopWorkflowId(), artifact.getLoopIdentity(), step);

    RunRequest runRequest =
        StepHelper.createInternalWorkflowRunRequest(
            workflowSummary,
            runtimeSummary,
            Collections.singletonList(Tag.create(WHILE_TAG_NAME)),
            createLoopRunParams(artifact.getLastIteration(), workflowSummary, step, runtimeSummary),
            generateDedupKey(artifact, nextInstanceId),
            null);

    if (!instanceStepConcurrencyHandler.addInstance(runRequest)) {
      return new Result(
          State.CONTINUE,
          Collections.emptyMap(),
          Collections.singletonList(
              TimelineLogEvent.info(
                  "Unavailable due to InstanceStepConcurrency and will retry later to launch the while loop iteration")));
    } // no need to release if exception

    Optional<Details> details =
        actionHandler.runInlineWorkflowInstance(
            inlineWorkflow,
            workflowSummary.getInternalId(), // inherit parent unique internalId
            workflowSummary.getWorkflowVersionId(), // inherit parent versionId
            workflowSummary.getRunProperties(), // inherit parent run properties
            step.getId(),
            artifact,
            runRequest,
            nextInstanceId);
    if (details.isPresent()) {
      LOG.warn(
          "In step runtime {}{}, failed to start while loop at iteration [{}], will try it again",
          workflowSummary.getIdentity(),
          runtimeSummary.getIdentity(),
          nextInstanceId);
      return new Result(
          State.CONTINUE,
          Collections.emptyMap(),
          Collections.singletonList(TimelineDetailsEvent.from(details.get())));
    } else {
      WorkflowRuntimeOverview overview = new WorkflowRuntimeOverview();
      overview.setRunStatus(WorkflowInstance.Status.CREATED);
      setNextIteration(artifact, nextInstanceId, overview.getRunStatus(), overview);
      LOG.debug(
          "In step runtime {}{}, have created while loop iteration [{}]",
          workflowSummary.getIdentity(),
          runtimeSummary.getIdentity(),
          nextInstanceId);
      return new Result(
          State.CONTINUE,
          Collections.singletonMap(artifact.getType().key(), artifact),
          Collections.emptyList());
    }
  }

  private void setNextIteration(
      WhileArtifact artifact,
      long nextInstanceId,
      WorkflowInstance.Status status,
      WorkflowRuntimeOverview overview) {
    artifact.setLastIteration(nextInstanceId);
    artifact.setLastStatus(status);
    if (artifact.getLastOverview() != null) {
      artifact.getRollup().aggregate(artifact.getLastOverview().getRollupOverview());
    }
    artifact.setLastOverview(overview);
  }

  private String generateDedupKey(WhileArtifact artifact, long instanceId) {
    return String.format(
        "[%s][%s][%s]", artifact.getLoopWorkflowId(), instanceId, artifact.getLoopRunId());
  }

  /**
   * Create an inline workflow definition for the while inline steps. It has empty params. All
   * params, including loop params and all workflow params and user defined step params (excluding
   * loop_params) inside while step, will be injected from run_params by workflow start request.
   */
  private static Workflow createInlineWorkflow(
      String loopWorkflowId, String loopIdentity, WhileStep step) {
    return Workflow.builder()
        .id(loopWorkflowId)
        .name(loopIdentity)
        .description(
            "Maestro while loop inline workflow including steps created by " + loopIdentity)
        .tags(step.getTags())
        // no need to set workflow timeout using whileStep.getTimeout()
        .params(Collections.emptyMap()) // no param in inline workflow definition
        .steps(step.getSteps())
        .build(); // inline steps won't inherit while step failure mode
  }

  private Map<String, ParamDefinition> createLoopRunParams(
      long loopIndex,
      WorkflowSummary workflowSummary,
      Step step,
      StepRuntimeSummary runtimeSummary) {
    Map<String, ParamDefinition> runParams = new LinkedHashMap<>();
    // all workflow params visible in the while loop will be passed to while loop inline workflow
    workflowSummary.getParams().forEach((k, v) -> runParams.put(k, v.toDefinition()));
    // all user defined params in the step definition will be passed to while loop inline workflow
    step.getParams()
        .forEach((k, v) -> runParams.put(k, runtimeSummary.getParams().get(k).toDefinition()));
    // remove while loop_params
    runParams.remove(Constants.LOOP_PARAMS_NAME);

    // inject loop_index, loop_params, while step condition param
    runParams.put(
        Constants.INDEX_PARAM_NAME,
        ParamDefinition.buildParamDefinition(Constants.INDEX_PARAM_NAME, loopIndex));
    MapParameter loopParams =
        runtimeSummary.getParams().get(Constants.LOOP_PARAMS_NAME).asMapParam();
    for (String name : loopParams.getParamNames()) {
      // Note that param loop_params only keep the original value.
      Parameter param = loopParams.getEvaluatedParam(name);
      switch (param.getType()) {
        case STRING:
          runParams.put(name, ParamDefinition.buildParamDefinition(name, param.asString()));
          break;
        case LONG:
          runParams.put(name, ParamDefinition.buildParamDefinition(name, param.asLong()));
          break;
        case DOUBLE:
          runParams.put(name, ParamDefinition.buildParamDefinition(name, param.asDouble()));
          break;
        case BOOLEAN:
          runParams.put(name, ParamDefinition.buildParamDefinition(name, param.asBoolean()));
          break;
        default:
          throw new MaestroInternalError(
              "Found an invalid loop param with name [%s] and type [%s] for while step %s",
              name, param.getType(), runtimeSummary.getIdentity());
      }
    }
    runParams.put(
        CONDITION_PARAM_NAME, ParamDefinition.buildParamDefinition(CONDITION_PARAM_NAME, true));

    return runParams;
  }

  /**
   * Terminate while step and all while loop iterations. API calls to kill or stop are captured in
   * the maestro task and terminate in step runtime always return STOPPED. It only monitors if all
   * while loop iterations are stopped. The action related to termination has already been written
   * to DB. The final step instance termination callback will do the cleanup, including the action
   * deletion.
   */
  @Override
  public Result terminate(WorkflowSummary workflowSummary, StepRuntimeSummary runtimeSummary) {
    if (runtimeSummary.getArtifacts().containsKey(Artifact.Type.WHILE.key())) {
      WhileArtifact artifact =
          runtimeSummary.getArtifacts().get(Artifact.Type.WHILE.key()).asWhile();
      var status = refreshIterationOverview(artifact);
      if (status == null
          || (artifact.getLastStatus() != null && !artifact.getLastStatus().isTerminal())) {
        tryTerminateQueuedInstanceIfNeeded(workflowSummary, runtimeSummary, artifact);
        wakeUpUnderlyingActor(workflowSummary, artifact);
        throw new MaestroRetryableError(
            "Termination at while step %s%s is not done and will retry it.",
            workflowSummary.getIdentity(), runtimeSummary.getIdentity());
      }
      return new Result(
          State.STOPPED,
          Collections.singletonMap(artifact.getType().key(), artifact),
          Collections.singletonList(
              TimelineLogEvent.info("Stopped all iterations because while step is terminated")));
    } else {
      LOG.debug(
          "while step {}{} haven't start any while loop iteration and do nothing.",
          workflowSummary.getIdentity(),
          runtimeSummary.getIdentity());
      return Result.of(State.STOPPED);
    }
  }

  /**
   * Refresh the iteration overview, and return the status of the last iteration if it matches
   * checkpoint. Otherwise, it returns null to indicate this case.
   *
   * @param artifact the while artifact to refresh
   * @return the status of the last iteration, null if checkpoint is not the latest iteration.
   */
  private WorkflowInstance.Status refreshIterationOverview(WhileArtifact artifact) {
    WorkflowInstance.Status ret = WorkflowInstance.Status.SUCCEEDED;
    if (artifact.getLastIteration() >= artifact.getFirstIteration()) {
      WorkflowInstance instance =
          instanceDao.getWorkflowInstanceRun(
              artifact.getLoopWorkflowId(), artifact.getLastIteration(), artifact.getLoopRunId());

      // update overview
      artifact.setLastStatus(instance.getStatus());
      artifact.setLastOverview(instance.getRuntimeOverview());
      ret = instance.getStatus();
    }

    // try to see if there is a lost iteration after the checkpoint
    long nextIterationId = artifact.getLastIteration() + 1;
    var status =
        instanceDao.getWorkflowInstanceStatus(
            artifact.getLoopWorkflowId(), nextIterationId, artifact.getLoopRunId());
    if (status != null) {
      var instance =
          instanceDao.getWorkflowInstanceRun(
              artifact.getLoopWorkflowId(), nextIterationId, artifact.getLoopRunId());
      setNextIteration(
          artifact, nextIterationId, instance.getStatus(), instance.getRuntimeOverview());
      artifact
          .getLoopParamValues()
          .forEach((k, v) -> v.add(instance.getParams().get(k).getEvaluatedResult()));
      return null; // indicate checkpoint is out of sync, need to track it again
    }

    return ret;
  }

  /** If the while loop instance is queued, then terminate it now. */
  private void tryTerminateQueuedInstanceIfNeeded(
      WorkflowSummary workflowSummary, StepRuntimeSummary runtimeSummary, WhileArtifact artifact) {
    if (artifact.getLastOverview() != null
        && artifact.getLastOverview().getRunStatus() == WorkflowInstance.Status.CREATED) {
      int terminated =
          instanceDao.terminateQueuedInstances(
              artifact.getLoopWorkflowId(),
              Constants.TERMINATE_BATCH_LIMIT,
              WorkflowInstance.Status.STOPPED,
              "The queued workflow instance is terminated by its upstream while step.");
      LOG.debug(
          "while step {}{} terminated [{}] queued while loop iterations.",
          workflowSummary.getIdentity(),
          runtimeSummary.getIdentity(),
          terminated);
      if (terminated != 1) { // unexpected
        LOG.error(
            "while step {}{} should only have one queued instance, but found [{}]. Please check it.",
            workflowSummary.getIdentity(),
            runtimeSummary.getIdentity(),
            terminated);
      }
    }
  }

  private void wakeUpUnderlyingActor(WorkflowSummary summary, WhileArtifact artifact) {
    var msg =
        MessageDto.createMessageForWakeUp(
            artifact.getLoopWorkflowId(),
            summary.getGroupInfo(),
            Map.of(artifact.getLastIteration(), artifact.getLoopRunId()));
    queueSystem.notify(msg);
  }
}
